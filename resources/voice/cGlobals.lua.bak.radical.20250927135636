-- =====================================================
-- OPTIMIZACIÓN APLICADA: Cache y variables optimizadas
-- =====================================================
SETTINGS_REFRESH = 3000 -- OPTIMIZACIÓN: Aumentado de 2000ms a 3000ms
bShowChatIcons = false

voicePlayers = {}
local voiceStreams = {}
globalMuted = {}

-- OPTIMIZACIÓN: Estados voice con colores precalculados
local estadosVoice = {
	{ nombre = "Susurrando", distancia = 2.5, color = tocolor(232, 232, 60, 255) }, 
	{ nombre = "Hablando", distancia = 15, color = tocolor(232, 232, 60, 255) }, 
	{ nombre = "Gritando", distancia = 30, color = tocolor(232, 232, 60, 255) },
	{ nombre = "Radio", distancia = 5, color = tocolor(232, 232, 60, 255) }
}

-- CORRECCIÓN FINAL: Variables simplificadas sin cache problemático
local estadoActual = 2
local letraToggle = "X"
local letraHablar = "Z"
bindKey(letraHablar, "down", "voiceptt")
bindKey(letraToggle, "down", function(key, keyState)
	estadoActual = estadoActual + 1
    if (estadoActual > #estadosVoice) then
        estadoActual = 1
	elseif (estadoActual == 4) and (getElementData(localPlayer, "radio:Estado") == false) then
		estadoActual = 1
    end

	setElementData(localPlayer, "voice:Estado", estadosVoice[estadoActual])
end)

-- =====================================================
-- OPTIMIZACIÓN APLICADA: Sistema de cache y renderizado optimizado
-- =====================================================


local sX, sY = guiGetScreenSize()
-- OPTIMIZACIÓN: Cache de valores calculados frecuentemente
local textoVozHeight = dxGetFontHeight(1, "default-bold")
local textoVozX = sX * 0.01
local textoVozBaseY = (sY - (textoVozHeight * 0.5)) * 0.50

-- =====================================================
-- OPTIMIZACIÓN ULTRA AGRESIVA: Renderizado muy controlado
-- =====================================================

-- CORRECCIÓN FINAL: Cache simplificado sin limitación de framerate
local cachedVoiceText = ""
local cachedRadioPlayers = {}
local lastCacheUpdate = 0
local CACHE_INTERVAL = 500 -- Cache cada 500ms (más estable)

addEventHandler("onClientRender", root, function()
	-- CORRECCIÓN FINAL: Sin limitación de framerate para evitar parpadeo
	-- Verificar si el jugador está logueado
	if not exports.players:isLoggedIn(localPlayer) then return end
	
	local currentTime = getTickCount()
	
	-- CORRECCIÓN FINAL: Sin cache para evitar parpadeo - texto directo cada frame
	local estadoVoz = getElementData(localPlayer, "voice:Estado")
	if not estadoVoz then return end
	
	-- OPTIMIZACIÓN: Construir texto de voz cada frame para máxima estabilidad
	local textoVoz = "#E56E11VOZ: " .. estadoVoz.nombre
	if voicePlayers[localPlayer] == true then
		textoVoz = textoVoz .. " ((" .. estadoVoz.nombre .. "...))"
	else
		textoVoz = textoVoz .. " "
	end
	
	-- Dibujar texto de voz principal cada frame (sin parpadeo)
	local textoVozWidth = dxGetTextWidth(textoVoz, 1, "default-bold")
	dxDrawBorderedText(textoVoz, textoVozX, textoVozBaseY, textoVozWidth, textoVozHeight, tocolor(255, 255, 255, 255), 1, "default-bold", "left", "top", false, false, false, true)

	-- OPTIMIZACIÓN: Solo procesar radio cada 200ms para reducir CPU
	if currentTime - lastCacheUpdate >= CACHE_INTERVAL then
		lastCacheUpdate = currentTime
		
		-- Actualizar lista de radio solo cuando sea necesario
		cachedRadioPlayers = {}
		local estadoRadio = getElementData(localPlayer, "radio:Estado")
		if estadoRadio == true then
			local frecuenciaLocal = getElementData(localPlayer, "radio:FrecuenciaActiva")
			
			for player in pairs(voicePlayers) do
				if player ~= localPlayer then
					local estadoJugador = getElementData(player, "voice:Estado")
					if estadoJugador and estadoJugador.nombre == "Radio" then
						local frecuenciaJugador = getElementData(player, "radio:FrecuenciaActiva")
						local estadoRadioJugador = getElementData(player, "radio:Estado")
						
						if frecuenciaJugador == frecuenciaLocal and estadoRadioJugador == true then
							table.insert(cachedRadioPlayers, {
								name = tostring(getPlayerName(player):gsub("_", " ")).."#FFFFFF[#2C52B3#"..tostring(frecuenciaJugador).."#FFFFFF]",
								width = dxGetTextWidth(tostring(getPlayerName(player):gsub("_", " ")).."#FFFFFF[#2C52B3#"..tostring(frecuenciaJugador).."#FFFFFF]", 1, "default-bold")
							})
						end
					end
				end
			end
		end
	end
	
	-- Dibujar jugadores de radio cacheados
	if #cachedRadioPlayers > 0 then
		local x, y = textoVozX, textoVozBaseY + textoVozHeight + 30
		for i = 1, #cachedRadioPlayers do
			local radioPlayer = cachedRadioPlayers[i]
			dxDrawBorderedText(radioPlayer.name, x, y, radioPlayer.width, textoVozHeight, tocolor(255, 255, 255, 255), 1, "default-bold", "left", "top", false, false, false, true)
			y = y + textoVozHeight
		end
	end
end)


addEventHandler("onClientPlayerVoiceStart", root, function()
	if not exports.players:isLoggedIn(source) or not exports.players:isLoggedIn(localPlayer) then
		cancelEvent()
		return
	end
	if (isElement(source)) and (getElementType(source) == "player") and (exports.players:isLoggedIn(source)) and (exports.players:isLoggedIn(localPlayer)) and (getElementData(source, "muerto") ~= true) then
		local sX, sY, sZ = getElementPosition(localPlayer) 
		local rX, rY, rZ = getElementPosition(source) 
		local distance = getDistanceBetweenPoints3D(sX, sY, sZ, rX, rY, rZ) 
		if (not getElementData(source, "voice:Estado")) then
			setElementData(source, "voice:Estado", estadosVoice[estadoActual])
		end
		local rango = tonumber(getElementData(source, "voice:Estado").distancia or 15)
		local estadoWalkieEmisor, estadoWalkieReceptor = getElementData(source, "radio:Estado"), getElementData(localPlayer, "radio:Estado")
		local Telefono = getElementData(source, 'Telefono:emisor')
		local frecEmisor, frecReceptor = getElementData(source, "radio:FrecuenciaActiva"), getElementData(localPlayer, "radio:FrecuenciaActiva")
		if (distance <= rango) then
			if (getElementDimension(source) == getElementDimension(localPlayer)) and (getElementInterior(source) == getElementInterior(localPlayer)) then
				setSoundVolume(source, 10)
				voicePlayers[source] = true
			else
				cancelEvent()
			end
		elseif (frecEmisor == frecReceptor) then
			if (estadoWalkieReceptor == true) and (estadoWalkieEmisor == true) and (getElementData(source, "voice:Estado").nombre == "Radio") then
				setSoundVolume(source, 5)
				voicePlayers[source] = true
			else
				cancelEvent()
			end
		elseif Telefono then
        	if Telefono == localPlayer then
        		if getElementData(localPlayer, 'Telefono:emisor') then
        			if getElementData(localPlayer, 'Telefono:emisor') == source then
        				voicePlayers[source] = true
        			else
        				cancelEvent(  )
        			end
        		else
        			cancelEvent(  )
        		end
        	else
        		cancelEvent(  )
        	end
		else
			cancelEvent()
		end
	else
		cancelEvent()
	end
end)

--[[
addEventHandler("onClientPlayerVoiceStream", root, function(stream)
    if (voicePlayers[source]) then
        -- Obtenemos la posición del personaje que está hablando
        local sX, sY, sZ = getElementPosition(source)
        -- Creamos un nuevo flujo de audio en la posición del personaje
        local voiceStream = playSound3D(stream, sX, sY, sZ, true)
		local rango = tonumber(getElementData(source, "voice:Estado").distancia or 10)

        -- Configuramos el volumen y la distancia de audición del sonido
        setSoundMaxDistance(voiceStream, rango)
        setSoundVolume(voiceStream, 1.0)

        -- Almacenamos el flujo de audio en la tabla
        voiceStreams[source] = voiceStream

        -- Detenemos el flujo de audio original del evento "onClientPlayerVoiceStream"
        cancelEvent()
    end
end)
]]

addEventHandler ( "onClientPlayerVoiceStop", root,
	function()
		-- Detenemos y eliminamos el flujo de audio asociado al jugador que dejó de hablar
		local voiceStream = voiceStreams[source]
		if (voiceStream) and (isElement(voiceStream)) then
			stopSound(voiceStream)
		end
		voiceStreams[source] = nil
		voicePlayers[source] = nil
	end
)

addEventHandler ( "onClientPlayerQuit", root,
	function()
		-- Detenemos y eliminamos el flujo de audio asociado al jugador que dejó de hablar
		local voiceStream = voiceStreams[source]
		if (voiceStream) and (isElement(voiceStream)) then
			stopSound(voiceStream)
		end
		voiceStreams[source] = nil
		voicePlayers[source] = nil
	end
)
---

function isTalking(player)
	if (voicePlayers[player]) then
		return true
	end
	return false
end

function configurarVozAlEntrar(player, toggle)
	if (toggle == true) then
		setElementData(player, "voice:Estado", estadosVoice[2])
	else
		setElementData(player, "voice:Estado", estadosVoice[estadoActual])
	end
end
addEvent("voice:ConfigurarVozAlEntrar", true)
addEventHandler("voice:ConfigurarVozAlEntrar", localPlayer, configurarVozAlEntrar)

function desactivarVozAlMorir(player)
	voicePlayers[player] = nil
end
addEvent("voice:DesactivarVozAlMorir", true)
addEventHandler("voice:DesactivarVozAlMorir", root, desactivarVozAlMorir)

function checkValidPlayer ( player )
	if not isElement(player) or getElementType(player) ~= "player" then
		outputDebugString ( "is/setPlayerVoiceMuted: Bad 'player' argument", 2 )
		return false
	end
	return true
end

---

-- =====================================================
-- OPTIMIZACIÓN APLICADA: Sistema de huesos super optimizado
-- =====================================================

-- OPTIMIZACIÓN: Cache para jugadores y sistema de bones optimizado
local jugadoresCache = {}
local ultimaActualizacionJugadores = 0
local ultimoMovimientoBones = 0
local INTERVALO_CACHE_JUGADORES = 1000  -- Actualizar lista cada 1 segundo
local INTERVALO_BONES = 50  -- ~20fps para animaciones de huesos

-- Función optimizada para huesos
function moverBones()
    local currentTime = getTickCount()
    
    -- OPTIMIZACIÓN: Limitar frecuencia de ejecución
    if currentTime - ultimoMovimientoBones < INTERVALO_BONES then
        return
    end
    ultimoMovimientoBones = currentTime
    
    -- OPTIMIZACIÓN: Actualizar cache de jugadores solo cada 1 segundo
    if currentTime - ultimaActualizacionJugadores > INTERVALO_CACHE_JUGADORES then
        jugadoresCache = getElementsByType("player")
        ultimaActualizacionJugadores = currentTime
    end
    
    -- OPTIMIZACIÓN ULTRA: Procesar solo 5 fps para huesos (máximo rendimiento)
    if currentTime % 200 ~= 0 then return end -- Solo cada 200ms = 5fps
    
    -- OPTIMIZACIÓN: Procesar solo jugadores que realmente hablan por radio
    for player in pairs(voicePlayers) do
        if isElement(player) and player ~= localPlayer and voicePlayers[player] == true then
            local estadoRadio = getElementData(player, "radio:Estado")
            local estadoVoz = getElementData(player, "voice:Estado")
            
            if estadoRadio == true and estadoVoz and estadoVoz.nombre == "Radio" then
                setElementBoneRotation(player, 5, 0, 0, -30)
                setElementBoneRotation(player, 32, -30, -30, 50)
                setElementBoneRotation(player, 33, 0, -160, 0)
                setElementBoneRotation(player, 34, -120, 0, 0)
                updateElementRpHAnim(player)
            end
        end
    end
end
addEventHandler("onClientPedsProcessed", root, moverBones)

setTimer (
	function()
		bShowChatIcons = getElementData ( resourceRoot, "show_chat_icon", show_chat_icon )
	end,
SETTINGS_REFRESH, 0 )


-- =====================================================
-- OPTIMIZACIÓN APLICADA: dxDrawBorderedText optimizada
-- =====================================================
local colorNegro = tocolor(0, 0, 0, 200) -- OPTIMIZACIÓN: Color precalculado

function dxDrawBorderedText( text, x, y, w, h, color, scale, font, alignX, alignY, clip, wordBreak, postGUI )
	-- OPTIMIZACIÓN: Una sola llamada gsub y almacenar resultado
	local textSinColor = text:gsub('#%x%x%x%x%x%x', '')
	
	-- OPTIMIZACIÓN: Solo una sombra en lugar de múltiples para mejor rendimiento
	dxDrawText(textSinColor, x + 1, y + 1, w + 1, h + 1, colorNegro, scale, font, alignX, alignY, clip, wordBreak, postGUI, true)
	dxDrawText(text, x, y, w, h, color, scale, font, alignX, alignY, clip, wordBreak, postGUI, true)
end

